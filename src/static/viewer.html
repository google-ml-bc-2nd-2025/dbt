<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>애니메이션 뷰어</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #container { width: 100%; height: 100vh; }
        .info { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px; 
            font-family: monospace;
            border-radius: 5px;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
        }
        .error {
            color: #ff4444;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div class="info">애니메이션 뷰어</div>
    <div id="loading" class="loading">모델 로딩 중...</div>

    <!-- 스크립트 호출 순서와 로드 방식 변경 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { BVHLoader } from 'three/addons/loaders/BVHLoader.js';
        
        // URL 파라미터 가져오기
        const urlParams = new URLSearchParams(window.location.search);
        const skinModelUrl = urlParams.get('skin');
        const animModelUrl = urlParams.get('anim');
        const animType = urlParams.get('animType') || 'glb'; // 애니메이션 타입 (기본값: glb)
        
        // 디버깅을 위한 URL 출력
        console.log('스킨 모델 URL:', skinModelUrl);
        console.log('애니메이션 URL:', animModelUrl);
        console.log('애니메이션 타입:', animType);

        // 로딩 상태 업데이트 함수
        function updateLoadingStatus(message, isError = false) {
            const loadingElement = document.getElementById('loading');
            loadingElement.innerHTML = message;
            if (isError) {
                loadingElement.classList.add('error');
            } else {
                loadingElement.classList.remove('error');
            }
        }

        // 씬 초기화
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);

        // 카메라 설정
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.5, 5);

        // 렌더러 설정
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // 컨트롤 설정 - 이 부분을 추가
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.update();

        // 조명 설정
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7.5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // 바닥 그리드 추가
        const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x444444);
        scene.add(gridHelper);

        // 바닥면 추가
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x666666,
            roughness: 0.8, 
            metalness: 0.2 
        });
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // 애니메이션 믹서 및 시계 설정
        let mixer;
        let bvhMixer; // BVH 애니메이션 믹서 별도 선언
        let bvhSkeletonHelper; // BVH 스켈레톤 헬퍼 참조 저장
        const clock = new THREE.Clock();

        // 로더 설정
        const gltfLoader = new GLTFLoader();

        // BVHLoader 추가 설정
        const bvhLoader = new BVHLoader();
        bvhLoader.animateBonePositions = false; // 본 위치 애니메이션 비활성화
        bvhLoader.animateBoneRotations = true; // 본 회전 애니메이션만 활성화

        let skinModel, skeletonHelper;
        let skeleton = null;

        // 스킨 모델 로드
        function loadSkinModel() {
            return new Promise((resolve, reject) => {
                if (!skinModelUrl) {
                    updateLoadingStatus('스킨 모델 URL이 없습니다.', true);
                    reject('스킨 모델 URL이 없습니다.');
                    return;
                }
                
                updateLoadingStatus('스킨 모델 로딩 중...');
                
                try {
                    const url = skinModelUrl;
                    console.log('로딩할 스킨 모델 URL:', url);
                    
                    gltfLoader.load(
                        url,
                        function(gltf) {
                            skinModel = gltf.scene;
                            scene.add(skinModel);
                            
                            console.log('스킨 모델 로드 성공');
                            
                            // 그림자 설정 및 스켈레톤 정보 캐시
                            skinModel.traverse(function(node) {
                                if (node.isMesh) {
                                    node.castShadow = true;
                                    node.receiveShadow = true;
                                    
                                    // 스켈레톤 정보 저장
                                    if (node.skeleton) {
                                        skeleton = node.skeleton;
                                        console.log('스켈레톤 찾음:', skeleton.bones.length, '개의 본');
                                        
                                        // 디버깅용: 모든 본 이름 출력
                                        skeleton.bones.forEach((bone, index) => {
                                            console.log(`본 ${index}: ${bone.name}`);
                                        });
                                    }
                                }
                            });
                            
                            // 모델 크기 및 위치 조정
                            const box = new THREE.Box3().setFromObject(skinModel);
                            const size = box.getSize(new THREE.Vector3()).length();
                            const center = box.getCenter(new THREE.Vector3());
                            
                            // 모델이 그리드 위에 오도록 위치 조정
                            skinModel.position.y = Math.abs(box.min.y);
                            
                            // 카메라 위치 조정
                            camera.position.copy(center);
                            camera.position.x += size / 2;
                            camera.position.y += size / 3;
                            camera.position.z += size;
                            controls.target.copy(center);
                            controls.update();
                            
                            // 애니메이션 믹서 생성
                            mixer = new THREE.AnimationMixer(skinModel);
                            
                            updateLoadingStatus('스킨 모델 로드 완료. 애니메이션 로딩 중...');
                            resolve(gltf);
                        },
                        // 로딩 진행상황
                        function(xhr) {
                            if (xhr.total > 0) {
                                const percent = Math.round(xhr.loaded / xhr.total * 100);
                                updateLoadingStatus(`스킨 모델 로드 중... ${percent}%`);
                            }
                        },
                        // 오류 발생 시
                        function(error) {
                            console.error('스킨 모델 로드 오류:', error);
                            updateLoadingStatus('스킨 모델 로드 오류: ' + error.message, true);
                            reject(error);
                        }
                    );
                } catch (error) {
                    console.error('스킨 모델 로딩 중 예외 발생:', error);
                    updateLoadingStatus('스킨 모델 로딩 중 예외 발생: ' + error.message, true);
                    reject(error);
                }
            });
        }

        // BVH 애니메이션 로드 및 적용 함수 - GLB 연결 코드 제거
        function loadBVHAnimation() {
            return new Promise((resolve, reject) => {
                if (!animModelUrl) {
                    console.log('BVH 애니메이션 URL이 없어 스킨만 표시합니다.');
                    resolve(null);
                    return;
                }
                
                updateLoadingStatus('BVH 애니메이션 로딩 중...');
                
                try {
                    const url = animModelUrl;
                    console.log('로딩할 BVH 애니메이션 URL:', url);
                    
                    bvhLoader.load(
                        url,
                        function(result) {
                            console.log('BVH 애니메이션 로드 성공');
                            
                            // GLB 모델 숨기기
                            if (skinModel) {
                                skinModel.visible = false;
                            }
                            
                            // BVH 본 계층 구조 생성
                            const bvhSkeleton = result.skeleton;
                            // 루트 본 정의
                            const rootBone = bvhSkeleton.bones[0];
                            // 애니메이션 클립 정의
                            const bvhClip = result.clip;
                            
                            // BVH 스켈레톤을 씬에 추가
                            scene.add(rootBone);
                            
                            // 스켈레톤 헬퍼 생성
                            bvhSkeletonHelper = new THREE.SkeletonHelper(rootBone);
                            bvhSkeletonHelper.material.linewidth = 2;
                            bvhSkeletonHelper.material.color = new THREE.Color(0x00ffff);
                            bvhSkeletonHelper.visible = true;
                            scene.add(bvhSkeletonHelper);
                            
                            // 본 시각화 코드
                            const jointMaterial = new THREE.MeshPhongMaterial({ 
                                color: 0x00aaff, 
                                shininess: 30,
                                transparent: true,
                                opacity: 0.8,
                                side: THREE.DoubleSide
                            });
                            
                            const jointMeshes = [];
                            // 관절 크기도 줄임 (0.2에서 0.04로 - 1/5 크기)
                            const jointSize = 0.04;

                            bvhSkeleton.bones.forEach((bone) => {
                                const mesh = new THREE.Mesh(
                                    new THREE.SphereGeometry(jointSize, 8, 8),
                                    jointMaterial.clone()
                                );
                                bone.add(mesh);
                                jointMeshes.push(mesh);
                            });
                            
                            // 골격 높이 분석
                            let lowestPoint = Infinity;
                            let highestPoint = -Infinity;
                            
                            // 먼저 스케일 설정
                            rootBone.scale.set(0.02, 0.02, 0.02); // 0.1에서 0.02로 변경 (1/5 크기)
                            
                            // 위치 초기화 후 분석 시작
                            rootBone.position.set(0, 0, 0);
                            rootBone.updateMatrixWorld(true);
                            
                            // 높이 분석 함수 정의 및 호출
                            function analyzeSkeletonHeightImproved(bone, parentWorldPos = new THREE.Vector3()) {
                                const localPos = bone.position.clone();
                                // 스케일 값 변경 (0.1에서 0.02로)
                                localPos.multiplyScalar(0.02);
                                
                                const worldPos = parentWorldPos.clone().add(localPos);
                                if (worldPos.y < lowestPoint) lowestPoint = worldPos.y;
                                if (worldPos.y > highestPoint) highestPoint = worldPos.y;
                                
                                for (let i = 0; i < bone.children.length; i++) {
                                    const child = bone.children[i];
                                    if (child.isBone) {
                                        analyzeSkeletonHeightImproved(child, worldPos);
                                    }
                                }
                            }
                            
                            analyzeSkeletonHeightImproved(rootBone);
                            
                            // 결과 출력
                            console.log('BVH 골격 높이 범위:', {lowestPoint, highestPoint});
                            
                            // 단 한 번만 위치 조정 (중복 코드 제거)
                            const heightAdjustment = -lowestPoint + 0.01;
                            rootBone.position.y = heightAdjustment;
                            rootBone.updateMatrixWorld(true);
                            
                            console.log('높이 조정값:', heightAdjustment);
                            
                            // BVH 애니메이션 믹서 생성
                            bvhMixer = new THREE.AnimationMixer(bvhSkeleton.bones[0]);
                            const animAction = bvhMixer.clipAction(bvhClip);
                            animAction.play();
                            
                            // 애니메이션 UI 추가
                            const infoElement = document.querySelector('.info');
                            if (infoElement) {
                                infoElement.innerHTML = 'BVH 애니메이션 뷰어';
                                
                                infoElement.innerHTML += `
                                <div style="margin-top: 10px;">
                                    <button id="toggle-play" style="margin-right: 5px;">일시정지</button>
                                    <button id="reset-view" style="margin-right: 5px;">뷰 리셋</button>
                                    <div style="margin-top: 5px;">
                                        <label for="anim-speed">속도: <span id="speed-value">1.0</span>x</label>
                                        <input type="range" id="anim-speed" min="0.1" max="2" step="0.1" value="1.0" style="width: 100%;">
                                    </div>
                                    <div style="margin-top: 5px;">
                                        <label for="height-adjust">높이 조정: <span id="height-value">${heightAdjustment.toFixed(3)}</span></label>
                                        <input type="range" id="height-adjust" min="${heightAdjustment-0.2}" max="${heightAdjustment+0.2}" step="0.005" value="${heightAdjustment}" style="width: 100%;">
                                    </div>
                                    <div style="margin-top: 5px;">
                                        <button id="toggle-skeleton" style="margin-right: 5px;">스켈레톤 표시/숨기기</button>
                                    </div>
                                </div>
                                `;
                                
                                setTimeout(() => {
                                    const playButton = document.getElementById('toggle-play');
                                    const resetButton = document.getElementById('reset-view');
                                    const speedSlider = document.getElementById('anim-speed');
                                    const speedValue = document.getElementById('speed-value');
                                    const heightSlider = document.getElementById('height-adjust');
                                    const heightValue = document.getElementById('height-value');
                                    const toggleSkeletonButton = document.getElementById('toggle-skeleton');
                                    
                                    let isPlaying = true;
                                    
                                    if (playButton) {
                                        playButton.addEventListener('click', () => {
                                            if (isPlaying) {
                                                animAction.paused = true;
                                                playButton.textContent = '재생';
                                            } else {
                                                animAction.paused = false;
                                                playButton.textContent = '일시정지';
                                            }
                                            isPlaying = !isPlaying;
                                        });
                                    }
                                    
                                    if (resetButton) {
                                        resetButton.addEventListener('click', () => {
                                            // 카메라 위치와 타겟 위치를 작은 모델에 맞게 조정
                                            camera.position.set(0, 0.5, 2); // 가까이 이동
                                            controls.target.set(0, 0.3, 0); // 타겟 위치 낮춤
                                            controls.update();
                                        });
                                    }
                                    
                                    if (speedSlider && speedValue) {
                                        speedSlider.addEventListener('input', (e) => {
                                            const speed = parseFloat(e.target.value);
                                            animAction.timeScale = speed;
                                            speedValue.textContent = speed.toFixed(1);
                                        });
                                    }
                                    
                                    if (heightSlider && heightValue) {
                                        heightSlider.addEventListener('input', (e) => {
                                            const height = parseFloat(e.target.value);
                                            rootBone.position.y = height;
                                            heightValue.textContent = height.toFixed(3);
                                            rootBone.updateMatrixWorld(true);
                                        });
                                    }
                                    
                                    if (toggleSkeletonButton) {
                                        toggleSkeletonButton.addEventListener('click', () => {
                                            bvhSkeletonHelper.visible = !bvhSkeletonHelper.visible;
                                        });
                                    }
                                }, 100);
                            }
                            
                            // 로딩 메시지 숨기기
                            setTimeout(() => {
                                document.getElementById('loading').style.display = 'none';
                            }, 1000);
                            
                            updateLoadingStatus('BVH 애니메이션 로드 완료');
                            resolve(result);
                        },
                        // 로딩 진행상황
                        function(xhr) {
                            if (xhr.total > 0) {
                                const percent = Math.round(xhr.loaded / xhr.total * 100);
                                updateLoadingStatus(`BVH 애니메이션 로드 중... ${percent}%`);
                            }
                        },
                        // 오류 발생 시
                        function(error) {
                            console.error('BVH 애니메이션 로드 오류:', error);
                            updateLoadingStatus('BVH 애니메이션 로드 오류: ' + error.message, true);
                            reject(error);
                        }
                    );
                } catch (error) {
                    console.error('BVH 애니메이션 로딩 중 예외 발생:', error);
                    updateLoadingStatus('BVH 애니메이션 로딩 중 예외 발생: ' + error.message, true);
                    reject(error);
                }
            });
        }

        // GLB 애니메이션 로드 함수
        function loadGLBAnimation() {
            return new Promise((resolve, reject) => {
                if (!animModelUrl) {
                    console.log('GLB 애니메이션 URL이 없어 스킨만 표시합니다.');
                    resolve(null);
                    return;
                }
                
                updateLoadingStatus('GLB 애니메이션 로딩 중...');
                
                try {
                    const url = animModelUrl;
                    console.log('로딩할 GLB 애니메이션 URL:', url);
                    
                    gltfLoader.load(
                        url,
                        function(gltf) {
                            console.log('GLB 애니메이션 로드 성공');
                            
                            // 애니메이션 추출
                            if (gltf.animations && gltf.animations.length > 0) {
                                console.log(`GLB 애니메이션 ${gltf.animations.length}개 발견`);
                                
                                if (mixer) {
                                    // 모든 애니메이션 재생
                                    const animationsPlayed = [];
                                    
                                    gltf.animations.forEach((clip, index) => {
                                        console.log(`애니메이션 ${index}: ${clip.name}, 길이: ${clip.duration}초`);
                                        
                                        try {
                                            // 애니메이션 클립으로 액션 생성 및 재생
                                            const action = mixer.clipAction(clip);
                                            action.play();
                                            animationsPlayed.push(clip.name || index);
                                        } catch (clipError) {
                                            console.error(`애니메이션 ${index} 적용 실패:`, clipError);
                                        }
                                    });
                                    
                                    if (animationsPlayed.length > 0) {
                                        updateLoadingStatus(`GLB 애니메이션 적용 완료: ${animationsPlayed.length}개 애니메이션`);
                                        setTimeout(() => {
                                            document.getElementById('loading').style.display = 'none';
                                        }, 1000);
                                    } else {
                                        updateLoadingStatus('애니메이션을 적용할 수 없습니다. 리깅 구조가 호환되지 않을 수 있습니다.', true);
                                    }
                                } else {
                                    console.error('애니메이션 믹서가 없어 애니메이션을 적용할 수 없습니다.');
                                    updateLoadingStatus('애니메이션 믹서가 없어 애니메이션을 적용할 수 없습니다.', true);
                                }
                            } else {
                                console.warn('GLB 파일에 애니메이션이 없습니다.');
                                updateLoadingStatus('GLB 파일에 애니메이션이 없습니다. 다른 파일을 시도해보세요.', true);
                            }
                            
                            resolve(gltf);
                        },
                        // 로딩 진행상황
                        function(xhr) {
                            if (xhr.total > 0) {
                                const percent = Math.round(xhr.loaded / xhr.total * 100);
                                updateLoadingStatus(`GLB 애니메이션 로드 중... ${percent}%`);
                            }
                        },
                        // 오류 발생 시
                        function(error) {
                            console.error('GLB 애니메이션 로드 오류:', error);
                            updateLoadingStatus('GLB 애니메이션 로드 오류: ' + error.message, true);
                            reject(error);
                        }
                    );
                } catch (error) {
                    console.error('GLB 애니메이션 로딩 중 예외 발생:', error);
                    updateLoadingStatus('GLB 애니메이션 로딩 중 예외 발생: ' + error.message, true);
                    reject(error);
                }
            });
        }

        // 모델이 로드되면, 부모 창에 메시지 전송
        function notifyParent(status) {
            try {
                window.parent.postMessage({
                    type: 'modelLoadStatus',
                    status: status
                }, '*');
            } catch (e) {
                console.error('부모 창에 메시지 전송 실패:', e);
            }
        }

        // 모델 로드 및 애니메이션 적용
        async function loadModels() {
            try {
                // 먼저 스킨 모델 로드
                await loadSkinModel();
                
                // 스킨 모델 로드 성공 후 애니메이션 로드 및 적용
                if (animModelUrl) {
                    try {
                        console.log(`애니메이션 타입: ${animType}`);
                        
                        if (animType.toLowerCase() === 'bvh') {
                            // BVH 애니메이션은 별도 처리 
                            await loadBVHAnimation();
                        } else {
                            // GLB 애니메이션만 스킨에 적용
                            await loadGLBAnimation();
                        }
                        
                        // 애니메이션 로드 성공 메시지
                        console.log(`${animType.toUpperCase()} 애니메이션 로드 완료`);
                    } catch (animError) {
                        console.error(`${animType.toUpperCase()} 애니메이션 로드 실패, 스킨만 표시합니다:`, animError);
                        updateLoadingStatus(`애니메이션 로드 실패, 스킨만 표시합니다. (오류: ${animError.message || animError})`);
                    }
                } else {
                    updateLoadingStatus('스킨 모델만 로드되었습니다. 애니메이션 없음.');
                }
                
                // 언제나 일정 시간 후 로딩 메시지 숨김
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1500);
                
                // 모델 로드 성공 알림
                notifyParent('success');
            } catch (error) {
                console.error('모델 로드 오류:', error);
                updateLoadingStatus('모델 로드 오류: ' + (error.message || error), true);
                
                // 모델 로드 실패 알림
                notifyParent('error');
            }
        }

        // 모델 로드 시작
        if (skinModelUrl) {
            loadModels();
        } else {
            updateLoadingStatus('스킨 모델이 지정되지 않았습니다.', true);
        }

        // 창 크기 변경 처리
        window.addEventListener('resize', onWindowResize);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 애니메이션 루프 수정
        function animate() {
            requestAnimationFrame(animate);
            
            // 델타 시간 계산
            const delta = clock.getDelta();
            
            // GLB 애니메이션 믹서 업데이트
            if (mixer) {
                mixer.update(delta);
            }
            
            // BVH 애니메이션 믹서 업데이트
            if (bvhMixer) {
                bvhMixer.update(delta);
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
