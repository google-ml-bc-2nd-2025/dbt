<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>애니메이션 뷰어</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #container { width: 100%; height: 100vh; }
        .info { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 10px; 
            font-family: monospace;
            border-radius: 5px;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
        }
        .error {
            color: #ff4444;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div class="info">애니메이션 뷰어</div>
    <div id="loading" class="loading">모델 로딩 중...</div>

    <!-- 스크립트 호출 순서와 로드 방식 변경 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { BVHLoader } from 'three/addons/loaders/BVHLoader.js';
        
        // 본 시각화 관련 전역 변수들 추가 - 파일 상단에 추가
        let skinModel, skeletonHelper;
        let skeleton = null;
        let jointMeshes = []; // 본 메시 배열
        let jointLabels = []; // 본 라벨 배열
        let boneLabelsVisible = false; // 본 라벨 가시성 상태

        // URL 파라미터 가져오기
        const urlParams = new URLSearchParams(window.location.search);
        const skinModelUrl = urlParams.get('skin');
        const animModelUrl = urlParams.get('anim');
        const animType = urlParams.get('animType') || 'glb'; // 애니메이션 타입 (기본값: glb)
                
        // SMPL HumanML3D에서 Mixamo 본 인덱스 매핑 추가
        const smpl_humanml3d_to_mixamo_index = [
            "mixamorig:Hips",           // 0 + 
            "mixamorig:LeftUpLeg",      // 1 + 
            "mixamorig:RightUpLeg",     // 2
            "mixamorig:Spine",          // 3 
            "mixamorig:LeftLeg",        // 4
            "mixamorig:RightLeg",       // 5
            "mixamorig:Spine1",         // 6 
            "mixamorig:LeftFoot",       // 7
            "mixamorig:RightFoot",      // 8
            "mixamorig:Spine2",         // 9
            "mixamorig:LeftToeBase",    // 10
            "mixamorig:RightToeBase",   // 11
            "mixamorig:Neck",           // 12 +
            "mixamorig:LeftShoulder",   // 13
            "mixamorig:RightShoulder",  // 14
            "mixamorig:Head",           // 15
            "mixamorig:LeftArm",        // 16
            "mixamorig:RightArm",       // 17
            "mixamorig:LeftForeArm",    // 18
            "mixamorig:RightForeArm",   // 19
            "mixamorig:LeftHand",       // 20
            "mixamorig:RightHand",      // 21
        ];

        // 디버깅을 위한 URL 출력
        console.log('스킨 모델 URL:', skinModelUrl);
        console.log('애니메이션 URL:', animModelUrl);
        console.log('애니메이션 타입:', animType);

        // 본 번호 표시를 위한 스프라이트와 캔버스 생성 함수 수정
        function createLabelSprite(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;
            
            // 배경 반투명
            context.fillStyle = 'rgba(0, 0, 0, 0.3)';
            context.fillRect(0, 0, 64, 64);
            
            // 텍스트 설정 - 크기 축소
            context.font = '14px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.fillText(text, 24, 24);
            
            // 텍스처 생성
            const texture = new THREE.CanvasTexture(canvas);
            
            // 스프라이트 생성 - 크기 축소
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.2, 0.2, 0.2);
            
            return sprite;
        }

        // 로딩 상태 업데이트 함수
        function updateLoadingStatus(message, isError = false) {
            const loadingElement = document.getElementById('loading');
            loadingElement.innerHTML = message;
            if (isError) {
                loadingElement.classList.add('error');
            } else {
                loadingElement.classList.remove('error');
            }
        }

        // 씬 초기화
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);

        // 카메라 설정
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.5, 5);

        // 렌더러 설정
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // 컨트롤 설정 - 이 부분을 추가
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.update();

        // 조명 설정
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7.5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // 바닥 그리드 추가
        const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x444444);
        scene.add(gridHelper);

        // 바닥면 추가
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x666666,
            roughness: 0.8, 
            metalness: 0.2 
        });
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // 애니메이션 믹서 및 시계 설정
        let mixer;
        let bvhMixer; // BVH 애니메이션 믹서 별도 선언
        let bvhSkeletonHelper; // BVH 스켈레톤 헬퍼 참조 저장
        const clock = new THREE.Clock();

        // 로더 설정
        const gltfLoader = new GLTFLoader();

        // BVHLoader 추가 설정
        const bvhLoader = new BVHLoader();
        bvhLoader.animateBonePositions = false; // 본 위치 애니메이션 비활성화
        bvhLoader.animateBoneRotations = true; // 본 회전 애니메이션만 활성화

        function getUniqueColor(index, total) {
            const hue = (index / total) * 360; // 색상 값 계산
            return new THREE.Color(`hsl(${hue}, 100%, 50%)`); // HSL 색상 생성
        }
        // 스킨 모델 로드
        function loadSkinModel() {
            return new Promise((resolve, reject) => {
                if (!skinModelUrl) {
                    updateLoadingStatus('스킨 모델 URL이 없습니다.', true);
                    reject('스킨 모델 URL이 없습니다.');
                    return;
                }
                
                updateLoadingStatus('스킨 모델 로딩 중...');
                
                try {
                    const url = skinModelUrl;
                    console.log('로딩할 스킨 모델 URL:', url);
                    
                    gltfLoader.load(
                        url,
                        function(gltf) {
                            skinModel = gltf.scene;
                            scene.add(skinModel);
                            
                            console.log('스킨 모델 로드 성공');
                            const diamondGeometry = new THREE.DodecahedronGeometry(0.05, 0); // 다이아몬드 메시 크기 조정
                            const jointSize = 0.05; // 본 크기 조정
                            
                            // 그림자 설정 및 스켈레톤 정보 캐시
                            skinModel.traverse(function(node) {
                                if (node.isMesh) {
                                    node.castShadow = true;
                                    node.receiveShadow = true;
                                    
                                    // 스켈레톤 정보 저장
                                    if (node.skeleton) {
                                        skeleton = node.skeleton;
                                        console.log('스켈레톤 찾음:', skeleton.bones.length, '개의 본');
                                        
                                        // 각 본마다 다이아몬드 메시와 라벨 추가 부분 수정
                                        skeleton.bones.forEach((bone, index) => {
                                            // 다이아몬드 메시 추가
                                            const color = getUniqueColor(index, skeleton.bones.length);
                                            const material = new THREE.MeshPhongMaterial({ 
                                                color: color, 
                                                shininess: 30,
                                                transparent: true,
                                                opacity: 0.8,
                                                side: THREE.DoubleSide
                                            });
                                            
                                            const mesh = new THREE.Mesh(diamondGeometry, material);
                                            mesh.rotation.set(
                                                Math.random() * Math.PI, 
                                                Math.random() * Math.PI, 
                                                Math.random() * Math.PI
                                            );
                                            mesh.visible = boneLabelsVisible; // 본 라벨 가시성 상태 설정
                                            bone.add(mesh);
                                            jointMeshes.push(mesh);
                                            
                                            // 현재 본 이름과 매핑 배열의 이름 비교
                                            let isMatched = false;
                                            let mappedIndex = -1;
                                            
                                            // 현재 본이 매핑 배열에 있는지 확인
                                            for (let i = 0; i < smpl_humanml3d_to_mixamo_index.length; i++) {
                                                const mixamoName = smpl_humanml3d_to_mixamo_index[i];
                                                const simpleName = mixamoName.replace('mixamorig:', '');
                                                
                                                if (bone.name === mixamoName || bone.name.includes(simpleName)) {
                                                    isMatched = true;
                                                    mappedIndex = i;
                                                    break;
                                                }
                                            }
                                            
                                            // 매칭된 본에만 라벨 추가
                                            if (isMatched) {
                                                // 각 본 인덱스에 해당하는 주석의 숫자 직접 입력
                                                // 매핑 배열의 주석에 있는 인덱스 값을 수동으로 설정
                                                const commentIndices = [
                                                    0,  // "mixamorig:Hips"           // 0 +
                                                    1,  // "mixamorig:LeftUpLeg"      // 1 + 
                                                    2,  // "mixamorig:RightUpLeg"     // 2
                                                    3,  // "mixamorig:Spine"          // 3
                                                    4,  // "mixamorig:LeftLeg"        // 4
                                                    5,  // "mixamorig:RightLeg"       // 5
                                                    6,  // "mixamorig:Spine1"         // 6
                                                    7,  // "mixamorig:LeftFoot"       // 7
                                                    8,  // "mixamorig:RightFoot"      // 8
                                                    9,  // "mixamorig:Spine2"         // 9
                                                    10, // "mixamorig:LeftToeBase"    // 10
                                                    11, // "mixamorig:RightToeBase"   // 11
                                                    12, // "mixamorig:Neck"           // 12 +
                                                    13, // "mixamorig:LeftShoulder"   // 13
                                                    14, // "mixamorig:RightShoulder"  // 14
                                                    15, // "mixamorig:Head"           // 15
                                                    16, // "mixamorig:LeftArm"        // 16
                                                    17, // "mixamorig:RightArm"       // 17
                                                    18, // "mixamorig:LeftForeArm"    // 18
                                                    19, // "mixamorig:RightForeArm"   // 19
                                                    20, // "mixamorig:LeftHand"       // 20
                                                    21, // "mixamorig:RightHand"      // 21
                                                ];
                                                
                                                const label = createLabelSprite(`${commentIndices[mappedIndex]}`);
                                                label.position.y = jointSize * 1.2;
                                                label.visible = boneLabelsVisible; // 본 라벨 가시성 상태 설정
                                                bone.add(label);
                                                jointLabels.push(label);
                                                
                                                console.log(`본 ${index} (${bone.name}) => 매핑 인덱스 ${mappedIndex} => SMPL 인덱스 ${commentIndices[mappedIndex]}`);
                                            } else {
                                                // 매칭되지 않은 본은 라벨 없음
                                                jointLabels.push(null);
                                            }
                                        });
                                    }
                                }
                            });
                            
                            // 모델 크기 및 위치 조정
                            const box = new THREE.Box3().setFromObject(skinModel);
                            const size = box.getSize(new THREE.Vector3()).length();
                            const center = box.getCenter(new THREE.Vector3());
                            
                            // 모델이 그리드 위에 오도록 위치 조정
                            skinModel.position.y = Math.abs(box.min.y);
                            
                            // 카메라 위치 조정
                            camera.position.copy(center);
                            camera.position.x += size / 2;
                            camera.position.y += size / 3;
                            camera.position.z += size;
                            controls.target.copy(center);
                            controls.update();
                            
                            // 애니메이션 믹서 생성
                            mixer = new THREE.AnimationMixer(skinModel);
                            
                            updateLoadingStatus('스킨 모델 로드 완료. 애니메이션 로딩 중...');
                            resolve(gltf);
                        },
                        // 로딩 진행상황
                        function(xhr) {
                            if (xhr.total > 0) {
                                const percent = Math.round(xhr.loaded / xhr.total * 100);
                                updateLoadingStatus(`스킨 모델 로드 중... ${percent}%`);
                            }
                        },
                        // 오류 발생 시
                        function(error) {
                            console.error('스킨 모델 로드 오류:', error);
                            updateLoadingStatus('스킨 모델 로드 오류: ' + error.message, true);
                            reject(error);
                        }
                    );
                } catch (error) {
                    console.error('스킨 모델 로딩 중 예외 발생:', error);
                    updateLoadingStatus('스킨 모델 로딩 중 예외 발생: ' + error.message, true);
                    reject(error);
                }
            });
        }

        // BVH 애니메이션 로드 및 적용 함수 - GLB 연결 코드 제거
        function loadBVHAnimation() {
            return new Promise((resolve, reject) => {
                if (!animModelUrl) {
                    console.log('BVH 애니메이션 URL이 없어 스킨만 표시합니다.');
                    resolve(null);
                    return;
                }
                
                updateLoadingStatus('BVH 애니메이션 로딩 중...');
                
                try {
                    const url = animModelUrl;
                    console.log('로딩할 BVH 애니메이션 URL:', url);
                    
                    bvhLoader.load(
                        url,
                        function(result) {
                            console.log('BVH 애니메이션 로드 성공');
                            
                            // GLB 모델 숨기기
                            if (skinModel) {
                                skinModel.visible = false;
                            }
                            
                            // BVH 본 계층 구조 생성
                            const bvhSkeleton = result.skeleton;
                            // 루트 본 정의
                            const rootBone = bvhSkeleton.bones[0];
                            // 애니메이션 클립 정의
                            const bvhClip = result.clip;
                            
                            // BVH 스켈레톤을 씬에 추가
                            scene.add(rootBone);
                            
                            // 스켈레톤 헬퍼 생성
                            bvhSkeletonHelper = new THREE.SkeletonHelper(rootBone);
                            bvhSkeletonHelper.material.linewidth = 2;
                            bvhSkeletonHelper.material.color = new THREE.Color(0x00ffff);
                            bvhSkeletonHelper.visible = true;
                            scene.add(bvhSkeletonHelper);
                            
                            // 본 시각화 코드
                            const jointMaterial = new THREE.MeshPhongMaterial({ 
                                color: 0x00aaff, 
                                shininess: 30,
                                transparent: true,
                                opacity: 0.8,
                                side: THREE.DoubleSide
                            });
                            
                            const jointMeshes = [];
                            // 관절 크기도 줄임 (0.2에서 0.04로 - 1/5 크기)
                            const jointSize = 0.04;

                            bvhSkeleton.bones.forEach((bone) => {
                                const mesh = new THREE.Mesh(
                                    new THREE.SphereGeometry(jointSize, 8, 8),
                                    jointMaterial.clone()
                                );
                                bone.add(mesh);
                                jointMeshes.push(mesh);
                            });
                            
                            // 골격 높이 분석
                            let lowestPoint = Infinity;
                            let highestPoint = -Infinity;
                            
                            // 먼저 스케일 설정
                            rootBone.scale.set(0.02, 0.02, 0.02); // 0.1에서 0.02로 변경 (1/5 크기)
                            
                            // 위치 초기화 후 분석 시작
                            rootBone.position.set(0, 0, 0);
                            rootBone.updateMatrixWorld(true);
                            
                            // 높이 분석 함수 정의 및 호출
                            function analyzeSkeletonHeightImproved(bone, parentWorldPos = new THREE.Vector3()) {
                                const localPos = bone.position.clone();
                                // 스케일 값 변경 (0.1에서 0.02로)
                                localPos.multiplyScalar(0.02);
                                
                                const worldPos = parentWorldPos.clone().add(localPos);
                                if (worldPos.y < lowestPoint) lowestPoint = worldPos.y;
                                if (worldPos.y > highestPoint) highestPoint = worldPos.y;
                                
                                for (let i = 0; i < bone.children.length; i++) {
                                    const child = bone.children[i];
                                    if (child.isBone) {
                                        analyzeSkeletonHeightImproved(child, worldPos);
                                    }
                                }
                            }
                            
                            analyzeSkeletonHeightImproved(rootBone);
                            
                            // 결과 출력
                            console.log('BVH 골격 높이 범위:', {lowestPoint, highestPoint});
                            
                            // 단 한 번만 위치 조정 (중복 코드 제거)
                            const heightAdjustment = -lowestPoint + 0.01;
                            rootBone.position.y = heightAdjustment;
                            rootBone.updateMatrixWorld(true);
                            
                            console.log('높이 조정값:', heightAdjustment);
                            
                            // BVH 애니메이션 믹서 생성
                            bvhMixer = new THREE.AnimationMixer(bvhSkeleton.bones[0]);
                            const animAction = bvhMixer.clipAction(bvhClip);
                            animAction.play();
                            
                            // 애니메이션 UI 추가
                            const infoElement = document.querySelector('.info');
                            if (infoElement) {
                                infoElement.innerHTML = 'BVH 애니메이션 뷰어';
                                
                                infoElement.innerHTML += `
                                <div style="margin-top: 10px;">
                                    <button id="toggle-play" style="margin-right: 5px;">일시정지</button>
                                    <button id="reset-view" style="margin-right: 5px;">뷰 리셋</button>
                                    <div style="margin-top: 5px;">
                                        <label for="anim-speed">속도: <span id="speed-value">1.0</span>x</label>
                                        <input type="range" id="anim-speed" min="0.1" max="2" step="0.1" value="1.0" style="width: 100%;">
                                    </div>
                                    <div style="margin-top: 5px;">
                                        <label for="height-adjust">높이 조정: <span id="height-value">${heightAdjustment.toFixed(3)}</span></label>
                                        <input type="range" id="height-adjust" min="${heightAdjustment-0.2}" max="${heightAdjustment+0.2}" step="0.005" value="${heightAdjustment}" style="width: 100%;">
                                    </div>
                                    <div style="margin-top: 5px;">
                                        <button id="toggle-skeleton" style="margin-right: 5px;">스켈레톤 표시/숨기기</button>
                                    </div>
                                </div>
                                `;
                                
                                setTimeout(() => {
                                    const playButton = document.getElementById('toggle-play');
                                    const resetButton = document.getElementById('reset-view');
                                    const speedSlider = document.getElementById('anim-speed');
                                    const speedValue = document.getElementById('speed-value');
                                    const heightSlider = document.getElementById('height-adjust');
                                    const heightValue = document.getElementById('height-value');
                                    const toggleSkeletonButton = document.getElementById('toggle-skeleton');
                                    
                                    let isPlaying = true;
                                    
                                    if (playButton) {
                                        playButton.addEventListener('click', () => {
                                            if (isPlaying) {
                                                animAction.paused = true;
                                                playButton.textContent = '재생';
                                            } else {
                                                animAction.paused = false;
                                                playButton.textContent = '일시정지';
                                            }
                                            isPlaying = !isPlaying;
                                        });
                                    }
                                    
                                    if (resetButton) {
                                        resetButton.addEventListener('click', () => {
                                            // 카메라 위치와 타겟 위치를 작은 모델에 맞게 조정
                                            camera.position.set(0, 0.5, 2); // 가까이 이동
                                            controls.target.set(0, 0.3, 0); // 타겟 위치 낮춤
                                            controls.update();
                                        });
                                    }
                                    
                                    if (speedSlider && speedValue) {
                                        speedSlider.addEventListener('input', (e) => {
                                            const speed = parseFloat(e.target.value);
                                            animAction.timeScale = speed;
                                            speedValue.textContent = speed.toFixed(1);
                                        });
                                    }
                                    
                                    if (heightSlider && heightValue) {
                                        heightSlider.addEventListener('input', (e) => {
                                            const height = parseFloat(e.target.value);
                                            rootBone.position.y = height;
                                            heightValue.textContent = height.toFixed(3);
                                            rootBone.updateMatrixWorld(true);
                                        });
                                    }
                                    
                                    if (toggleSkeletonButton) {
                                        toggleSkeletonButton.addEventListener('click', () => {
                                            bvhSkeletonHelper.visible = !bvhSkeletonHelper.visible;
                                        });
                                    }
                                }, 100);
                            }
                            
                            // 로딩 메시지 숨기기
                            setTimeout(() => {
                                document.getElementById('loading').style.display = 'none';
                            }, 1000);
                            
                            updateLoadingStatus('BVH 애니메이션 로드 완료');
                            resolve(result);
                        },
                        // 로딩 진행상황
                        function(xhr) {
                            if (xhr.total > 0) {
                                const percent = Math.round(xhr.loaded / xhr.total * 100);
                                updateLoadingStatus(`BVH 애니메이션 로드 중... ${percent}%`);
                            }
                        },
                        // 오류 발생 시
                        function(error) {
                            console.error('BVH 애니메이션 로드 오류:', error);
                            updateLoadingStatus('BVH 애니메이션 로드 오류: ' + error.message, true);
                            reject(error);
                        }
                    );
                } catch (error) {
                    console.error('BVH 애니메이션 로딩 중 예외 발생:', error);
                    updateLoadingStatus('BVH 애니메이션 로딩 중 예외 발생: ' + error.message, true);
                    reject(error);
                }
            });
        }

        // GLB 애니메이션 로드 함수
        function loadGLBAnimation() {
            return new Promise((resolve, reject) => {
                if (!animModelUrl) {
                    console.log('GLB 애니메이션 URL이 없어 스킨만 표시합니다.');
                    resolve(null);
                    return;
                }
                
                updateLoadingStatus('GLB 애니메이션 로딩 중...');
                
                try {
                    const url = animModelUrl;
                    console.log('로딩할 GLB 애니메이션 URL:', url);
                    
                    gltfLoader.load(
                        url,
                        function(gltf) {
                            console.log('GLB 애니메이션 로드 성공');

                            console.log(gltf.animations, gltf.animations.length + '개 애니메이션');
                            console.log(gltf)

                            // 애니메이션 추출
                            if (gltf.animations && gltf.animations.length > 0) {
                                console.log(`GLB 애니메이션 ${gltf.animations.length}개 발견`);

                                if (mixer) {
                                    // 모든 애니메이션 재생
                                    const animationsPlayed = [];
                                    
                                    gltf.animations.forEach((clip, index) => {
                                        console.log(`애니메이션 ${index}: ${clip.name}, 길이: ${clip.duration}초`);
                                        
                                        try {
                                            // 애니메이션 클립으로 액션 생성 및 재생
                                            const action = mixer.clipAction(clip);
                                            action.play();
                                            animationsPlayed.push(clip.name || index);
                                        } catch (clipError) {
                                            console.error(`애니메이션 ${index} 적용 실패:`, clipError);
                                        }
                                    });
                                    
                                    // 애니메이션 UI 추가 (GLB 애니메이션 성공적으로 로드된 후)
                                    if (animationsPlayed.length > 0) {
                                        updateLoadingStatus(`GLB 애니메이션 적용 완료: ${animationsPlayed.length}개 애니메이션`);
                                        
                                        // 애니메이션 컨트롤 UI 추가
                                        let infoElement = document.querySelector('.info');
                                        if (infoElement) {
                                            // 애니메이션 정보 및 컨트롤러 추가
                                            let clip = gltf.animations[0]; // 첫 번째 애니메이션 기준
                                            console.log('애니메이션 클립:', clip);
                                            let duration = clip.duration;
                                            let frameCount = Math.round(duration * 30); // 30fps 기준 프레임 수 계산
                                            // extras 메타데이터가 있으면 사용
                                            if (clip.userData && clip.userData.extras) {
                                                if (clip.userData.extras.duration) duration = clip.userData.extras.duration;
                                                if (clip.userData.extras.frame_count) frameCount = clip.userData.extras.frame_count;
                                            }
                                            console.log('애니메이션 클립:', clip, '길이:', duration, '초, 프레임 수:', frameCount);

                                            infoElement.innerHTML = 'GLB 애니메이션 뷰어';
                                            infoElement.innerHTML += `
                                            <div style="margin-top: 10px;">
                                                <div style="display: flex; align-items: center; margin-bottom: 5px;">
                                                    <button id="toggle-play" style="margin-right: 5px; width: 80px;">일시정지</button>
                                                    <span id="time-display">0.00 / ${duration.toFixed(2)}s</span>
                                                </div>
                                                <div style="display: flex; align-items: center;">
                                                    <input type="range" id="anim-timeline" min="0" max="${duration}" step="0.01" value="0" style="flex-grow: 1;">
                                                    <span id="frame-display" style="margin-left: 5px; width: 60px; text-align: right;">0/${frameCount}</span>
                                                </div>
                                                <div style="margin-top: 5px;">
                                                    <label for="anim-speed">속도: <span id="speed-value">1.0</span>x</label>
                                                    <input type="range" id="anim-speed" min="0.1" max="2" step="0.1" value="1.0" style="width: 100%;">
                                                </div>
                                                <div style="margin-top: 5px;">
                                                    <button id="reset-view">시점 리셋</button>
                                                    <button id="bone_id_show">본 인덱스 보기/숨기기</button>
                                                </div>
                                            </div>
                                            `;
                                            
                                            // 컨트롤 이벤트 리스너 설정
                                            setTimeout(() => {
                                                const playButton = document.getElementById('toggle-play');
                                                const timelineSlider = document.getElementById('anim-timeline');
                                                const timeDisplay = document.getElementById('time-display');
                                                const frameDisplay = document.getElementById('frame-display');
                                                const speedSlider = document.getElementById('anim-speed');
                                                const speedValue = document.getElementById('speed-value');
                                                const resetButton = document.getElementById('reset-view');
                                                const boneIdShowButton = document.getElementById('bone_id_show');
                                                
                                                // 현재 애니메이션 액션 참조 저장
                                                const actions = [];
                                                gltf.animations.forEach(clip => {
                                                    const action = mixer.clipAction(clip);
                                                    actions.push(action);
                                                });
                                                
                                                let isPlaying = true;
                                                let currentAction = actions[0];
                                                
                                                if (playButton) {
                                                    playButton.addEventListener('click', () => {
                                                        if (isPlaying) {
                                                            // 일시정지
                                                            actions.forEach(action => action.paused = true);
                                                            playButton.textContent = '재생';
                                                        } else {
                                                            // 재생
                                                            actions.forEach(action => action.paused = false);
                                                            playButton.textContent = '일시정지';
                                                        }
                                                        isPlaying = !isPlaying;
                                                    });
                                                }
                                                
                                                if (timelineSlider && timeDisplay) {
                                                    // 타임라인 슬라이더 업데이트 함수
                                                    const updateTimeDisplay = (time) => {
                                                        // 시간 표시 업데이트
                                                        timeDisplay.textContent = `${time.toFixed(2)} / ${duration.toFixed(2)}s`;
                                                        // 프레임 표시 업데이트
                                                        const frame = Math.round(time * 30); // 30fps 가정
                                                        frameDisplay.textContent = `${frame}/${frameCount}`;
                                                    };
                                                    
                                                    // 슬라이더 변경 이벤트
                                                    timelineSlider.addEventListener('input', (e) => {
                                                        const time = parseFloat(e.target.value);
                                                        
                                                        // 애니메이션 일시정지
                                                        const wasPlaying = isPlaying;
                                                        if (isPlaying) {
                                                            actions.forEach(action => action.paused = true);
                                                            playButton.textContent = '재생';
                                                            isPlaying = false;
                                                        }
                                                        
                                                        // 모든 애니메이션 위치 설정
                                                        actions.forEach(action => {
                                                            action.time = time % action.getClip().duration;
                                                        });
                                                        
                                                        // 시간 표시 업데이트
                                                        updateTimeDisplay(time);
                                                        
                                                        // 믹서 강제 업데이트
                                                        if (mixer) mixer.update(0);
                                                    });
                                                    
                                                    // 슬라이더에서 마우스를 놓았을 때
                                                    timelineSlider.addEventListener('change', () => {
                                                        // 슬라이더 조작 완료 후 자동 재생
                                                        if (!isPlaying) {
                                                            actions.forEach(action => action.paused = false);
                                                            playButton.textContent = '일시정지';
                                                            isPlaying = true;
                                                        }
                                                    });
                                                    
                                                    // 애니메이션 시간을 주기적으로 업데이트
                                                    const updateAnimationTime = () => {
                                                        if (actions.length > 0 && isPlaying) {
                                                            const time = actions[0].time;
                                                            timelineSlider.value = time;
                                                            updateTimeDisplay(time);
                                                        }
                                                        requestAnimationFrame(updateAnimationTime);
                                                    };
                                                    updateAnimationTime();
                                                }
                                                
                                                if (speedSlider && speedValue) {
                                                    speedSlider.addEventListener('input', (e) => {
                                                        const speed = parseFloat(e.target.value);
                                                        actions.forEach(action => action.timeScale = speed);
                                                        speedValue.textContent = speed.toFixed(1);
                                                    });
                                                }
                                                
                                                if (resetButton) {
                                                    resetButton.addEventListener('click', () => {
                                                        // 카메라 위치 리셋
                                                        const box = new THREE.Box3().setFromObject(skinModel);
                                                        const size = box.getSize(new THREE.Vector3()).length();
                                                        const center = box.getCenter(new THREE.Vector3());
                                                        
                                                        camera.position.copy(center);
                                                        camera.position.x += size / 2;
                                                        camera.position.y += size / 3;
                                                        camera.position.z += size;
                                                        controls.target.copy(center);
                                                        controls.update();
                                                    });
                                                }
                                                if(boneIdShowButton){
                                                    boneIdShowButton.addEventListener('click', () => {
                                                        // 본 인덱스 보기/숨기기
                                                        boneLabelsVisible = !boneLabelsVisible;
                                                        console.log('본 인덱스 보기/숨기기:', boneLabelsVisible ? '보임' : '숨김');
                                                        
                                                        // 모든 본 라벨의 가시성 토글
                                                        jointLabels.forEach(label => {
                                                            if (label) { // null이 아닌 경우에만
                                                                label.visible = boneLabelsVisible;
                                                            }
                                                        });
                                                        jointMeshes.forEach(mesh => {
                                                            mesh.visible = boneLabelsVisible;
                                                        });
                                                        
                                                        // 버튼 텍스트 업데이트
                                                        boneIdShowButton.textContent = boneLabelsVisible ? 
                                                            '본 인덱스 숨기기' : '본 인덱스 보기';
                                                    });
                                                }
                                            }, 100);
                                        }
                                        
                                        setTimeout(() => {
                                            document.getElementById('loading').style.display = 'none';
                                        }, 1000);
                                    } else {
                                        updateLoadingStatus('애니메이션을 적용할 수 없습니다. 리깅 구조가 호환되지 않을 수 있습니다.', true);
                                    }
                                } else {
                                    console.error('애니메이션 믹서가 없어 애니메이션을 적용할 수 없습니다.');
                                    updateLoadingStatus('애니메이션 믹서가 없어 애니메이션을 적용할 수 없습니다.', true);
                                }
                            } else {
                                console.warn('GLB 파일에 애니메이션이 없습니다.');
                                updateLoadingStatus('GLB 파일에 애니메이션이 없습니다. 다른 파일을 시도해보세요.', true);
                            }
                            
                            resolve(gltf);
                        },
                        // 로딩 진행상황
                        function(xhr) {
                            if (xhr.total > 0) {
                                const percent = Math.round(xhr.loaded / xhr.total * 100);
                                updateLoadingStatus(`GLB 애니메이션 로드 중... ${percent}%`);
                            }
                        },
                        // 오류 발생 시
                        function(error) {
                            console.error('GLB 애니메이션 로드 오류:', error);
                            updateLoadingStatus('GLB 애니메이션 로드 오류: ' + error.message, true);
                            reject(error);
                        }
                    );
                } catch (error) {
                    console.error('GLB 애니메이션 로딩 중 예외 발생:', error);
                    updateLoadingStatus('GLB 애니메이션 로딩 중 예외 발생: ' + error.message, true);
                    reject(error);
                }
            });
        }

        // 모델이 로드되면, 부모 창에 메시지 전송
        function notifyParent(status) {
            try {
                window.parent.postMessage({
                    type: 'modelLoadStatus',
                    status: status
                }, '*');
            } catch (e) {
                console.error('부모 창에 메시지 전송 실패:', e);
            }
        }

        // 모델 로드 및 애니메이션 적용
        async function loadModels() {
            try {
                // 먼저 스킨 모델 로드
                await loadSkinModel();
                
                // 스킨 모델 로드 성공 후 애니메이션 로드 및 적용
                if (animModelUrl) {
                    try {
                        console.log(`애니메이션 타입: ${animType}`);
                        
                        if (animType.toLowerCase() === 'bvh') {
                            // BVH 애니메이션은 별도 처리 
                            await loadBVHAnimation();
                        } else {
                            // GLB 애니메이션만 스킨에 적용
                            await loadGLBAnimation();
                        }
                        
                        // 애니메이션 로드 성공 메시지
                        console.log(`${animType.toUpperCase()} 애니메이션 로드 완료`);
                    } catch (animError) {
                        console.error(`${animType.toUpperCase()} 애니메이션 로드 실패, 스킨만 표시합니다:`, animError);
                        updateLoadingStatus(`애니메이션 로드 실패, 스킨만 표시합니다. (오류: ${animError.message || animError})`);
                    }
                } else {
                    updateLoadingStatus('스킨 모델만 로드되었습니다. 애니메이션 없음.');
                }
                
                // 언제나 일정 시간 후 로딩 메시지 숨김
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1500);
                
                // 모델 로드 성공 알림
                notifyParent('success');
            } catch (error) {
                console.error('모델 로드 오류:', error);
                updateLoadingStatus('모델 로드 오류: ' + (error.message || error), true);
                
                // 모델 로드 실패 알림
                notifyParent('error');
            }
        }

        // 모델 로드 시작
        if (skinModelUrl) {
            loadModels();
        } else {
            updateLoadingStatus('스킨 모델이 지정되지 않았습니다.', true);
        }

        // 창 크기 변경 처리
        window.addEventListener('resize', onWindowResize);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 애니메이션 루프 수정
        function animate() {
            requestAnimationFrame(animate);
            
            // 델타 시간 계산
            const delta = clock.getDelta();
            
            // GLB 애니메이션 믹서 업데이트
            if (mixer) {
                mixer.update(delta);
            }
            
            // BVH 애니메이션 믹서 업데이트
            if (bvhMixer) {
                bvhMixer.update(delta);
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
```html
